    Hello! So it seems to me that there are two major paths
    to decide between for the thing to add next:

        * Control structures (if/else, loops)
        * Write compiled programs to ELF executables

    Both will be challenging. I'm leaning towards ELF at the
    moment. We'll see what I think when I come back tomorrow
    night.

    Two nights later: Yup, gonna try to write an ELF
    executable. This is gonna be cool!

    First, I need to test writing a file. Then write the ELF
    header, then the contents of a word.

    I'll start by having 'make_elf' take a token (will use
    as an output filename for writing the executable and,
    later, the word get the machine code from).

    Then I'll write the string 'ELF' to that file. (Which is
    very appropriate because Bytes 2-5 of a _real_ ELF
    header are that string.)

    Next night: So I've got my test 'make_elf' and it is
    supposed to be writing to whatever filename you want:

        make_elf foo

    That should write the string 'ELF' to a file called
    'foo', but it's not. So I've inserted a DEBUG to see
    what the fd returned from 'open' is:

$ mr
make_elf foo
new fd: fffffffe
Goodbye.
Exit status: 0

    Yeah, that's definitely an error.

    While looking for how to decode that error (the open(2)
    man page explains the errors, but they're all C mnemonic
    constants, of course), I came across this excellent
    suggestion on SO: https://stackoverflow.com/a/68155464

    Which was to use strace to decode the error for me!

$ strace ./meow5
execve("./meow5", ["./meow5"], 0x7fff2d4ec190 /* 60 vars */) = 0
[ Process PID=2579 runs in 32 bit mode. ]
read(0, make_elf foo
"make_elf foo\n", 1024)         = 13
open("foo", O_WRONLY|0xc)               = -1 ENOENT (No such file or directory)
write(1, "new fd: ", 8new fd: )                 = 8
write(1, "fffffffe\n", 9fffffffe
)               = 9
write(-2, "ELF", 3)                     = -1 EBADF (Bad file descriptor)
read(0, "", 1024)                       = 0
write(1, "Goodbye.\n", 9Goodbye.
)               = 9
exit(0)                                 = ?
+++ exited with 0 +++

    Huh, so something's wrong with my attempt to open the
    output file with write-only, create, and truncate flags.

    Here's what I'm sending:

        ; From open(2) man page:
        ;   A call to creat() is equivalent to calling open()
        ; with flags equal to O_CREAT|O_WRONLY|O_TRUNC.
        ; I got the flags by searching all of /usr/include and
        ; finding /usr/include/asm-generic/fcntl.h
        ; That yielded (along with bizarre comment "not fcntl"):
        ;   #define O_CREAT   00000100
        ;   #define O_WRONLY  00000001
        ;   #define O_TRUNC   00001000
        ; Hence this flag value for 'open':
        mov ecx, 1101b

    But from the strace above, it looks like it sees
    O_WRONLY and...0xC - which is, indeed 1100...

    Sounds like I've got a mystery for tomorrow night.

    Two nights later: I bet somebody out there is
    screaming. Ha ha. Those numbers are in octal, not binary
    (despite looking for all the world like bit flags).

    So I fixed that one night. Then I had to learn how to
    set the mode (permissions), which was, like, freakishly
    hard to find online. All the 'open' examples I found
    were opening existing files. But since CREAT is an
    option, obviously there was a way to do it...

    The search "32 x86 assembly linux syscall table" is the
    blessed way to ask the major search engines.

    The answer is: the mode bits (in the usual unix octal
    owner/group/all format) go in register edx. So:

        ; ebx contains null-terminated word name (see above)
        mov ecx, (0100o | 0001o | 1000o)  ; open flags
        mov edx, 666o                     ; mode (permissions)
        mov eax, SYS_OPEN
        int 80h ; now eax will contain the new file desc.

    And when I went to test it, I was sleepy and forgot that
    since I was running the binary from strace, it wasn't
    gonna re-build from source like my shell aliases 'mr',
    'mb', 'mt' do, so I couldn't figure out why it wasn't
    working...

    ...until I woke up in the middle of the night with the
    realization.

    Anyway, next morning, here goes:

$ strace ./meow5
execve("./meow5", ["./meow5"], 0x7fff56d5ec40 /* 60 vars */) = 0
[ Process PID=1377 runs in 32 bit mode. ]
read(0, make_elf foo
"make_elf foo\n", 1024)         = 13
open("foo", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
write(1, "new fd: ", 8new fd: )                 = 8
write(1, "00000003\n", 900000003
)               = 9
write(3, "ELF", 3)                      = 3
read(0, "", 1024)                       = 0
write(1, "Goodbye.\n", 9Goodbye.
)               = 9
exit(0)                                 = ?
+++ exited with 0 +++

    Awesome, we can see the flags being correctly decoded
    and the mode/permission param:

        open("foo", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3

    So I've learned that strace rules for this sort of thing!

    But did it work?

$ cat foo
ELF

    Yahoo! Ha ha, I have written a string to a new file.
    Jeez, that was way harder than I expected.

    But now I can actually try writing an ELF header. I'm
    excited.

    -------------------------------------------------------

    11 nights later: It's the holiday season, which is a lot
    of exhausting activity (if you're a parent) under the
    best of circumstances and this was an unusually hard one
    for the family. So what I could easily have done in a
    single night ended up stretching out for many nights.
    But I finally finished the header portion in the .data
    section and am writing it with the 'make_elf' word (I am
    *not* writing the word yet).

    Let's see what it does so far:

$ mr
make_elf exit
new fd: 00000003
Goodbye.
Exit status: 0

    The "new fd" message is a DEBUG statement I apparently
    left in there to make sure I was opening the file
    correctly.

    If I've done everything correctly, this will have
    written a file named "exit" with a more-or-less correct
    ELF header.

    Let's see what 'file' thinks of it:

$ file exit
exit: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), can't read elf program headers at 184, no section header

    Not bad! The program headers error might be due to a bug
    in my headers or just the fact that I'm not writing the
    program to the file yet.

    Let's see what 'readelf' says:

$ readelf -a exit
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048000
  Start of program headers:          184 (bytes into file)
  Start of section headers:          0 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         1
  Size of section headers:           0 (bytes)
  Number of section headers:         0
  Section header string table index: 0

    ...

readelf: exit: Error: Reading 32 bytes extends past end of file for program headers

    Yeah, so it looks like my program header offset might be
    wrong. But otherwise, the decoding looks correct!
