    Well, log05.txt ended with some great excitement. I
    double-checked and all of the open TODOs are now closed.

    So I think I'll dip into design-notes.txt and pick the
    next thing to do.

    I just remembered one thing, I need to _remove_ a
    feature: the return stack doesn't need to be a stack at
    all because my "inline all the things!" language can't
    have nested word calls anyway:

        [ ] Replace return stack with single addr

    So, that's not super rewarding, but I do enjoy deleting
    uneeded code.

    Oh, I know which feature I'm doing after that! Time to
    reward myself for staying on track with something fun
    and visual:

        [ ] Pretty-print meta info about word!
        [ ] Loop through dictionary, list all names
        [ ] Loop through dictionary, pretty-print all

    Next night: De-evolving the return mechanism for
    immediate word calling was easy, so that one's done.

    Now for the fun ones.

    I'm more of a strings programmer than a numbers
    programmer. So the ultra-primitive state of my string
    printing is a bit of a bummer. Before I start storing a
    billion little pieces of strings in the DATA segment,
    I'd like to consider adding some convenience words for
    string handling.

    It would be nice to have, at the very least, string
    literals in the language.

        [ ] Add string literals.
        [ ] Re-define 'meow' using a string literal.

    I like the idea of just writing "anonymous" strings to
    be printed into the dictionary space where all the words
    are. And I think my choice to null-terminate my strings
    will pay off here (I hope).

    Adding immediate mode strings that are just references
    to the input buffer turned out to be super easy:

        ; IMMEDIATE version of " scans forward until it finds end
        ; quote '"' character in input_buffer and replaces it with
        ; the null terminator. Leaves start addr of string on the
        ; stack. Use it right away!
        DEFWORD quote
            mov ebp, [input_buffer_pos]
            inc ebp ; skip initial space
            push ebp ; we leave this start addr on the stack
        .look_for_endquote:
            inc ebp
            cmp byte [ebp], '"' ; endquote?
            jne .look_for_endquote ; nope, loop
            mov byte [ebp], 0   ; replace endcquote with null
            inc ebp ; move past the new null terminator
            mov [input_buffer_pos], ebp ; save position
        ENDWORD quote, '"', (IMMEDIATE)

    And now I can do my first legit Hello World:

        db ' " Hello world!" print newline exit '

    Which works just fine:

$ mr
Hello world!

    But since it just saves a reference to the input buffer,
    real world usage won't really be safe. Unless the input
    buffer is limitless, I hae no idea if the string address
    will still be valid by the time I try to use it.

    For that reason, I'm gonna have to copy any strings from
    the input buffer to somewhere.

    I could either have a special-purpose buffer just for
    storing strings, or I could write to the stack, or I
    could write to the compile area.

    The other thing that's really messing with my mind is
    trying to think ahead (probably way too much) towards
    how I might handle this stuff in a stand-alone
    executable program produced by Meow5...which, now that
    I've written it out, is DEFINITELY thinking ahead too
    far ahead.

    Next night: Moving on, I've also decided that I should
    extract the part of 'get_token' that eats any initial
    space characters (or other whitespace) out into its own
    word.

        [ ] New word: 'eat_spaces'

    That will allow me to use it to "peek ahead" if I
    want to in the outer interpreter and possibly switch
    into a "string mode" (which is something I'm
    contemplating). But all these paragraphs are me getting
    way ahead of myself. Back to the assembly!

    Okay, done. I had just one mistake, but GDB was a clumsy
    way to debug it. So I added some more print debugging,
    leading to this extremely verbose output once it worked:

$ mr
Running ":"
Inlining "meow"
Inlining "meow"
Inlining "meow"
Inlining "meow"
Inlining "meow"
Running ";"
Running "meow5"
Meow. Meow. Meow. Meow. Meow. Running "newline"

Running "exit"

    I'll comment those out for now, but I'm betting I'll be
    using them again soon.

$ mr
Meow. Meow. Meow. Meow. Meow.

    There we are, good as new.

    Next night: So while it's true that I could save strings
    (and other data) in a variety of clever places, my
    understanding is that modern CPUs do much better with
    separate instruction and data memory.

    So I'm gonna say for now that there will be three types
    of memory in Meow5:

        1. The stack for all register-sized parameters
        2. The "compile area" where all inlined words go
        3. The "data area" where all variables and other
           data (such as "anonymous" strings) will go.

    In fact, I'm gonna name #2 and #3 exactly like that:

        section .bss

        ...

        compile_area: resb 1024
        data_area:    resb 1024

        here: resb 4
        free: resb 4

    Where 'here' points to the next free spot in the
    compile_area (the 'here' name comes from Forth).

    And 'free' points to the next free spot in the
    data_area.

    And I'm gonna go against the Forth grain and add a
    special handler for quote syntax. I'll go ahead and peek
    at the next character of input. If it's a quote, I'll
    handle the rest as a string. Otherwise, keep processing
    tokens as usual.

    The word is called 'quote' instead of '"' and I'm going
    to call it explicitly in my outer interpreter.

    The point of this is to allow "normal looking" strings
    like this:

        "Hello world"

    Rather than requring a token delimeter after the '"'
    word as in traditional Forth:

        " Hello world"

    Between that and copying the string from the input
    buffer to a new variable space, the change in my
    immediate mode hello world is just the missing space,
    but it's a world of difference:

        db ' "Hello World!" print newline exit '

    Does it work?

$ mr
Hello World!

    Compile mode is exactly the same (I'll put the string in
    the data_area at compile time), but instead of pushing
    the address of the string to the stack right at that
    momment, I need to inline (or "compile") the machine
    code to push the address *when the word being compiled
    runs*!

    To do that, I need to actually "assemble" the i386
    opcode to push the 32-bit address onto the stack.

    So that'll be the "PUSH imm32" instruction in Intel
    documentation parlance.

    Handy reference: https://www.felixcloutier.com/x86/push

        6A <ib> PUSH imm8
        66 <iw> PUSH imm16
        68 <id> PUSH imm32

    And I'm gonna test that out with NASM and GDB:

        push byte  0x99
        push word  0x8888
        push dword 0x77777777

    disassembles as:

0x0804942d <+0>:	6a 99	push   $0xffffff99
0x0804942f <+2>:	66 68 88 88	pushw  $0x8888
0x08049433 <+6>:	68 77 77 77 77	push   $0x77777777

    Bingo! So I'm going to want opcode 0x68 followed by
    the address value.
        
        mov edx, [here]
        mov byte [edx], 0x68     ; i386 opcode for PUSH imm32
        mov dword [edx + 1], ebx ; address of string
        add edx, 5               ; update here
        mov [here], edx          ; save it

    Well, here goes nothing...

        db ': meow "Meow." print ; meow newline exit '

    There's no way that's gonna work...

$ mr
Running ":"
Inlining "print"
Running ";"
Running "meow"
Meow.Running "newline"

Running "exit"

    What?! It worked!

    As you can see, I had also turned my debugging
    statements back on 'cause I was expecting trouble. They
    help assure me that this is, in fact compiling a word
    called 'meow' that prints a string stored in memory at
    compile time. I'll turn the debugging off again.

    And while I'm at it, I'll remove the old assembly test
    'meow' word and define it like this in order to create
    the 'meow5' word.


        input_buffer:
            db ': meow "Meow." print ; '
            db ': meow5 meow meow meow meow meow ; '
            db 'meow5 '
            db 'newline '
            db 'exit',0

./build.sh: line 33:  2650 Segmentation fault      ./$F

    Aw man.

    Okay, were are we crashing?

(gdb) r
Starting program: /home/dave/meow5/meow5
Running ":"
Inlining "print"
Running ";"
Running ":"
Inlining "meow"
Inlining "meow"
Inlining "meow"

Program received signal SIGSEGV, Segmentation fault.
find.test_word () at meow5.asm:165
165	    and eax, [edx + T_FLAGS] ; see if mode bit is set...

    Hmmm. Weird that it dies while trying to find the fourth
    'meow' to inline. I bumped up the compile area memory to
    4kb and it wasn't that. So I guess I'll be stepping
    through this.
