    So log01.txt concluded with a nice little demonstration
    of programatically inlining machine code at runtime to
    "compile" a program and run it.

    The next step is to start to turn this into an actual
    language by creating headers for words (I've decided
    I'll use the Forth term "word" to refer to the functions
    we create in this language).

        1. Look up word length from header so it doesn't
           have to be manually created and sent to the
           inline function.

        2. Look up word by stored ASCII  name in header at
           runtime. That'll be exciting. I'll practically
           have a programming language at that point.

    I think I'll use a linked list of words like many
    traditional Forths, since that's what I learned how to
    implement in my JONESFORTH port, nasmjf.

    Note: I added design-notes.txt to this repo because I
          have been having some on-going thoughts about how
          to implement this program as a whole, but they're
          not things I can act upon right away and I don't
          want to have to come back here searching in these
          logs to find them (or worse, forget about them
          entirely!)

    Okay, now I've got #1 from above list working. Instead
    of a "header", I've got "tails" at the end of my words.
    Ha ha, cats have tails. So this just keeps getting
    better.

    I did it that way because then it becomes trivial to get
    the length of the machine code. Here's the definition of
    the exit word now, with its tail:

        exit:
            mov ebx, 0 ; exit with happy 0
            mov eax, SYS_EXIT
            int 0x80
        exit_tail:
            dd 0 ; null link is end of linked list
            dd (exit_tail - exit) ; len of machine code
            db "exit", 0 ; name, null-terminated

    So now I don't have to give the length of the word's
    machine code to inline anymore, just the tail address.
    inline gets the stored length and does all the rest!

    Here's the new inline:

        ; inline function!
        ;   input: esi - tail of the word to inline
        inline:
            mov edi, [here]    ; destination
            mov ecx, [esi + 4] ; get len into ecx
            sub esi, ecx       ; sub len from  esi (start of code)
            rep movsb ; movsb copies from esi to esi+ecx into edi
            add edi, ecx       ; update here pointer...
            mov [here], edi    ; ...and store it
            ret

    Still not too complicated. And I think this might even
    be its final form?

    Let's see if this works...

Program received signal SIGSEGV, Segmentation fault.
inline () at meow5.asm:67
67	    rep movsb

    Darn it.

    Oh, wait! It was inlining the meows just fine, it was
    doing exit that failed. I simply hadn't updated it to
    point to the tail yet. Simple mistake:

        ; inline exit
        mov esi, exit   <---- oops!
        call inline

    needs to be:

        ; inline exit
        mov esi, exit_tail
        call inline

    How about now...

$ mrun
Meow.
Meow.
Meow.
Meow.
Meow.

    Awesome! Guess I can start making it find words by ASCII
    name in the tails, searching by linked list. Very
    exciting progress tonight!

