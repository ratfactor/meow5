    The last update was very exciting. Now I'm actually
    reading a single word's definition from a string,
    inlining all of the code into memory, and executing it.

    To put it in concrete terms, this 'meow5' definition:

        "meow meow meow meow meow exit"

    Was turned into this in memory:

        <meow word machine code>
        <meow word machine code>
        <meow word machine code>
        <meow word machine code>
        <exit word machine code>

    The 'exit' word even pops the exit status code from the
    stack. Between that and all of the meowing, we're
    getting extremely "conCATenative" here. Sorry.

    So I need to figure out what step comes next. I need to:

        1. Get user input from STDIN
        2. Figure out how immediate mode will work
           (currently, i start in compile mode and when
           that's done, I execute whatever was compiled!)
        3. Create the colon ':' and semicolon ';' words to
           toggle compile mode (and create word definitions!)

    I would also like to have introspection and diagnostics
    and visualizations as early in this project as possible!
    But for now, I'm gonna stay the course towards an
    absolutely minimumal proof of concept. I want to be able
    to type this:

        : meow5 meow meow meow meow meow exit ;
        meow5

    And see (something like) this:

        Meow.
        Meow.
        Meow.
        Meow.
        Meow.
        BYE!
        $

    So how about #2 and/or #3 from the list above - how
    simple can the colon command be?

    So I've updated the input string:

        db 'meow  : meow5 meow meow meow meow meow ;
            meow5 exit', 0

    (ignore the newline)
    Which reads as:

        1. call meow right now in "immediate" mode
        2. : switches to compile mode and
        3. store "meow5" as name
        4. inline 5 meow words
        5. ; writes tail (including saved name) and
        6. switches back to immediate mode
        7. call new meow5 word
        8. exit

    and have created a mode var and added imm/comp flags to
    tails. todo:

    [ ] colon word store name somewhere
    [ ] find should also match mode flag (use &)
    [ ] semicolon should write tail
    [ ] immediate mode should find and exec words...somehow

    Next two nights: Hmm...okay, so adding more words that
    will execute as they're entered ("immediate" words) is
    forcing me to deal with how they should return execution
    to whatever called them.

    To recap:

        * Compiled code in meow5 will be concatenated
          together, so there is no such thing as "return"
          _within_ a compiled word - execution truly just
          flows from the end of one word to the beginning of
          the next.

        * Many words (':' or 'colon' is an example), which
          must be able to operate outside of a compiled word
          because it is needed to do the compiling!

        * Some words can execute _both_ ways in a single
          definition. 'exit' is my only example currently -
          it's simple because no part of the program needs
          to execute after it's done, of course.

        * A select few words will even need to be executed
          from within the meow5 binary itself (in assembly)
          to make the initial functionality of the
          interpreter available. 'find' and 'inline' are two
          such fundamental words.

        * I've slowly been converting all of the traditional
          procedure calls in this prototype into simple
          jumps and manually keeping track of a single level
          of return address.

    Now the ':' command forces me to implement a return
    stack for immediate execution, at the very least,
    because it will need to call, for instance, 'get_token',
    to get the name of the word being defined:

        : meow 5 ...;

    Here 'meow5' is the name of the new word.

    Anyway, after sleeping on it, I think I'll solve this by
    having macros to start and end a word in assembly. In
    addition to taking care of the housekeeping duties of
    creating the tail metadata, they'll also setup return
    jumping and stack poppin'. The length of the word in the
    tail will NOT include the return stuff so it won't be
    included when the word is inlined.

    Anyway, it makes sense in my head.

    The basic word-making macros are easy enough:

        %macro DEFWORD 1 ; takes name of word to make
            %1:
        %endmacro

        %macro ENDWORD 3
            end_%1:
            ; todo: immediate "return" goes here
            tail_%1:
                dd LAST_WORD_TAIL ; linked list
                %define LAST_WORD_TAIL tail_%1
                dd (tail_%1 - %1) ; length of word
                dd %3             ; flags
                db %2, 0        ; name as string
        %endmacro

    I tested this and I'll spare you the GDB walkthrough. It
    works and I was able to execute this word from my input
    string.

        DEFWORD foo
            mov eax, 42
        ENDWORD foo, "foo", IMMEDIATE

    So I'll test a call/return action with this foo, then
    return them all...
