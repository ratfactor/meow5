    It's pretty wild what I *don't* yet have in this
    language:

        * Basic math operations
        * Conditionals
        * Loops
        * User-defined variables

    The easiest one to rectify, I think, will be some basic
    math operations. With that, I can at least have a decent
    RPN calculator.

    Before I do that, I'd like to now start separating the
    language primitives I used in the creation of the
    interpreter versus everyhing else.

    Putting everything else in another file and including it
    turns out to be super easy with NASM:

        %include 'stdlib.asm'

    So far, stdlib.asm contains just these:

        ps (print stack)
        inspect
        inspect_all
        all (all names)

    So now I'll...YUCK, nevermind! NASM doesn't report the
    line number of an error in an included file - it really
    pretends the included content is actually in the file
    that did the including. It was probably premature to
    split this up anyway.

    So everything will stay in meow5.asm as before.

    Okay, so the math operations are easy because I'm just
    popping the arguments, calling the CPU instructions, and
    pushing the answer:

$ mr
20 8 - ps
12
4 * ps
48
3 / ps
0 16
"4 divided by 3 is $ remainder $\n" print
4 divided by 3 is 16 remainder 0
bin
1011 0100 + ps
1111
1111 hex ps
f f
0beef ps
f f beef
+ ps
f befe
+ ps
bf0d
Goodbye.
Exit status: 0

    Increment and decrement! Bam! Easy!

45 inc ps
46
dec dec dec ps
43

    I love easy stuff!

    I'll need to figure out some more substantial stuff
    next. Variables, maybe. Or conditionals.

    Next week: I chose to implement variables first. Then I
    took some time off to rest a bit.

    Now I've got a first stab at 'var'.

    (I originally planned to have variables put their VALUES
    on the stack when called, but after I started
    implementing them, I've decided to follow yet another
    Forth convention: variables will put their ADDRESSES on
    the stack. It's just so much simpler and more flexible
    that way.)

    So far, 'var' borrows from three existing words:

        1. From 'colon', it takes the idea of getting the
           next token from the input stream as a name.

        2. From 'quote', it takes the compiling of the
           machine code to push the immediate value
           containing the address of the variable's memory.

        3. From 'semicolon' - actually, it doesn't borrow,
           it flat out *includes* semicolon.

    Does it work?

var foo
hex foo "Address of foo: $\n" print
Address of foo: 804c16c
var bar
hex bar "Address of bar: $\n" print
Address of bar: 804c189

    Seems plausible! So I guess I need new words to get
    values to/from that address and the stack.

    I think I'll call them "get" and "set" rather than the !
    ("store") and @ ("fetch") terminology from Forth.

    They're easy to write in assembly. Just a handful of
    instructions.

    Here goes:

var foo
42 foo set
: foo? foo "Foo contains $\n" print ;
foo?
./build.sh: line 34:  1465 Segmentation fault      ./$F
Exit status: 139

    Oops, I didn't even write that correctly. I forgot the
    'get' in the definition of 'foo?'. But it should still
    have printed the address of foo. So something has gone
    awry. Now I know what I'm doing tomorrow night.

    Next night: Okay, let's see where this crashes using
    GDB. First, Can I set and get the variable?

Starting program: /home/dave/meow5/meow5
var foo
55 foo set
foo get
ps
134525204 55

    Yes! Okay, I've got some extra garbage on the stack
    (looks like an address that I'm not cleaing up at some
    point). I'll deal with that in good time.

    But 55 on the stack totally means 'foo get' worked.
    Neat!

    And can I print it from a string in immediate mode?

"foo is $\n" print
foo is 55

    No problemo.

    Now in a compiled word where it crashed last night.
    (This time I remembered to do a 'get' as well):

: foo? foo get "foo=$\n" ;
foo?

Program received signal SIGSEGV, Segmentation fault.
0x0804b114 in token_buffer ()

    Yeah, so there we are. Apparently it crashes
    while...what? Trying to execute code in token_buffer?

    Well, I think the real problem is probably something
    fundamental. Like, I haven't really thought through how
    something works in a compiled word versus immediate
    mode.

